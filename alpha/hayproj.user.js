// ==UserScript==
// @name           Haystack Project Search Obfuscator
// @namespace      http://www.haystackproject.org
// @description    Creates fake searches and clickthroughs for search terms generated by the Haystack Project web search tool 
// @version        0.1
// @author         David Huerta
// @license        AGPL
// @include        http://*.haystackproject.org/alpha/search.htm*
// @include        http://*.haystackproject.com/alpha/search.htm*
// ==/UserScript==

// set up an event listener so that the GS function can be accessed
var btnSearch = document.getElementById('btnSearch');
btnSearch.addEventListener('click', webSearch(true), false);

function window.webSearch(isUserTerm)
{
	var searchTerm = document.getElementById('txtSearchBox').value;
	var randomWordOrder = document.getElementById('chkReorderPhrase').checked;
	var includeTypos = document.getElementById('chkIncludeTypos').checked;
	var ghtMinDate = new Date();
	var ghtTerms1 = new Array();
	var ghtTerms2 = new Array();
	var terms = [];
	
	// Set the first date that GHT terms are available... this might change periodically...
	ghtMinDate.setFullYear(2007);
	ghtMinDate.setMonth(4);
	ghtMinDate.setDate(15);
	
	// Do a search burst, use the php scraper.
	// Right now only GHT
	ghtTerms1 = getTermsFromGoogleHotTrends(randomDate(ghtMinDate, new Date()), randomNumberBetwixt(5, 10));
	//ghtTerms1 = getTermsFromGoogleHotTrends(randomDate(ghtMinDate, new Date()), randomNumberBetwixt(8, 8)); // DEBUG
	
	ghtTerms2 = getTermsFromGoogleHotTrends(randomDate(ghtMinDate, new Date()), randomNumberBetwixt(5, 10));// MIN DATE CHANGES. TODO: Find out how often Google changes it
	//ghtTerms2 = getTermsFromGoogleHotTrends(randomDate(ghtMinDate, new Date()), randomNumberBetwixt(9, 9)); // DEBUG
	
	terms = ghtTerms1.concat(ghtTerms2);
	
	if (randomWordOrder)
	{
		userTerm = '';	
		var userTermWords = searchTerm.split(' ');
		
		userTermWords.sort(randomness);
		
		for (var x=0; x<userTermWords.length; x++)
		{
			userTerm += userTermWords[x] + ' ';
		}
		
		for (var x=0; x<terms.length; x++)
		{
			var fakeTermWords = terms[x].split(' ');
			var fakeTerm = '';
			
			fakeTermWords.sort(randomness);
			
			for (var y=0; y<fakeTermWords.length; y++)
			{
				fakeTerm += fakeTermWords[y] + ' ';
			}
			
			terms[x] = fakeTerm;
		}
	}
	else
	{
		userTerm = searchTerm;	
	}
	
	if (includeTypos)
	{
		// under construction...
		// TODO: Write artifical misspelling function
	}
	
	if (withUserTerm == true)
	{
		terms.push(userTerm);
	}
	
	terms.sort(randomness);
	
	displaySearchBurst(terms);
	
	for (var x=0; x<terms.length; x++)
	{
		//alert('term being scoured: ' + terms[x]);
		
		if (terms[x] == userTerm)
		{
			gSearch(terms[x], true);
		}
		else
		{
			gSearch(terms[x], false);
		}	
	}
	
	// clear out term so that its not searched again by the next artificial search burst
	document.getElementById('txtSearchBox').value = "";
	document.getElementById('txtSearchBox').focus();
	
	setTimeout('webSearch(false);', randomNumberBetwixt(30000, 300000));
}

function gSearch(searchTerm, isUserTerm)
{
	var gSearchPhrase = '';
	var gSearchUrl = 'http://www.google.com/search?q=';
	var gTerms = searchTerm.split(' ');
	
	for (var x=0; x<gTerms.length; x++)
	{
		if (x == (gTerms.length -1))
		{
			gSearchPhrase += gTerms[x].toLowerCase();
		}
		else
		{
			gSearchPhrase += gTerms[x].toLowerCase() + '+';
		}
	}
	
	if (isUserTerm)
	{
		// NOTE: No clickthrough obfuscation on user searches; Overlapping clickthroughs could indicate whether it was human generated; Plus the results page would have to be fetched twice, adding another red forensic flag
		window.open(gSearchUrl + gSearchPhrase);
	}
	else
	{
		GM_xmlhttpRequest({
    		method: 'GET',
    		url: gSearchUrl + gSearchPhrase,
    		headers: {
       	 		'User-agent': navigator.userAgent, //e.g. 'Mozilla/4.0 (compatible) Greasemonkey',
        		//'Accept': 'application/atom+xml,application/xml,text/xml',
    		},
    		onload: gClicks;
		});
	}
}

function gClicks(searchPageResponse)
{
	var clickThroughUrls = gResultLinks(searchPageResponse);
	clickThroughUrls.sort(randomness); // randomness is defined in randomCore.js
	
	// the more things the user can click on, the greater the chance the number of clickthroughs will be abnormally large...
	// it might be advisable to add a bias for < 5ish
	randomNumberBetwixt(0, clickThroughUrls.length);
	
	for (var x=0; x<clickThruUrls.length; x++)
	{
		GM_xmlhttpRequest({
    		method: 'GET',
    		url: clickThroughUrls[x],
    		headers: {
       	 		'User-agent': navigator.userAgent,
    		},
    		onload: function(responseDetails) 
    		{
    			// we're done here...
    		}
		});
	}
}

function gResultLinks(searchPageResponse)
{
	// TODO: adjust regex to look for clk results or if clk's parms are too diff, write a whole seperate thing for it...
    var arrResultLinkAttribs = searchPageResponse.responseText.match(/<[^>]*rn rwt[^>]*>/g);
    
    var arrRealLinks = new Array();
    // grab ei var from window.google defintion: ,ei:"desu"
    var eiValMatches = searchPageResponse.responseText.match(/ei:\"[^\"]*\"/g);
   	//alert('ei var from window.google: ' + responseDetails.responseText.match(/<script>[^>]*>/g)); // this shows everything...
    var eiVal = eiValMatches[0].substring(4,eiValMatches[0].length-1);
    
    for (var x=0; x<arrResultLinkAttribs.length; x++)
    {
    	var realUrl = arrResultLinkAttribs[x].match(/ref=\"[^\"]*\"/g)[0]; // this will failwhale is no match is found...	
    	// remove leading ref=" and trailing "
    	var realRealUrl = realUrl.substring(5,realUrl.length-1);
    	
    	arrRealLinks.push(realRealUrl);
    }
    
    // TODO: Also need an array for google.com href's that don't use rwt, like links to youtube clips, etc...
    
    // yo dawg, we heard you liek arrays...
    var arrLinkParms = new Array();
    
    for (var x=0; x<arrResultLinkAttribs.length; x++)
    {
    	var firstParen = arrResultLinkAttribs[x].indexOf('(');
    	var lastParen = arrResultLinkAttribs[x].lastIndexOf(')');
    	
    	var arrParms = arrResultLinkAttribs[x].substring(firstParen + 1, lastParen).split(',');
    	
    	arrLinkParms.push(arrParms);
    }
    
    var clickThruUrls = new Array();
    
    // go through the array of rwt parameter arrays and replace the 'this' parm with the real link and add ei
    for (var x=0; x<arrLinkParms.length; x++)
    {
    	arrLinkParms[x][0]=arrRealLinks[x]; // this will epically failwhale if the two regexes aren't getting the same link infoz
    	arrLinkParms[x].push(eiVal);
    	
    	// also remove leading and trailing single quotes in the parms extracted from the rwt call...
    	var clickThruUrl = gUrl(arrLinkParms[x][0]
    		,arrLinkParms[x][1].substring(1,arrLinkParms[x][1].length-1)
    		,arrLinkParms[x][2].substring(1,arrLinkParms[x][2].length-1)
    		,arrLinkParms[x][3].substring(1,arrLinkParms[x][3].length-1)
    		,arrLinkParms[x][4].substring(1,arrLinkParms[x][4].length-1)
    		,arrLinkParms[x][5].substring(1,arrLinkParms[x][5].length-1)
    		,'&' + arrLinkParms[x][6].substring(6,arrLinkParms[x][6].length-1) // sig2 has an & that gets encoded when rendered on the page, so we're removing "'&amp;" ... and decodeURIComponent() is being teh dumbz
    		,arrLinkParms[x][7].substring(1,arrLinkParms[x][7].length-1)
    		,arrLinkParms[x][8]);
    		
    	clickThruUrls.push(clickThruUrl);
    }
    
    return clickThruUrls;
}

// This function does what rwt() does in Google's search results page
function gUrl(realUrl,oi,cad,ct,cd,usg,sig2,ved,ei)
{
	var obeseSisterUrl = ['http://www.google.com/url?sa=t','\x26source\x3dweb'
		,oi?'&oi='+encodeURIComponent(oi):''
		,cad?'&cad='+encodeURIComponent(cad):''
		,'&ct=',encodeURIComponent(ct||'res')
		,'&cd=',encodeURIComponent(cd)
		,'&ved=',encodeURIComponent(ved)
		,'&url=',encodeURIComponent(realUrl).replace(/\+/g,'%2B')
		,'&ei=',ei
		,usg?'&usg='+usg:'',sig2].join('');
		
	return obeseSisterUrl;
}